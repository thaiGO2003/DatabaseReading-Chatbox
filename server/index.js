const express = require("express");
const cors = require("cors");
const dotenv = require("dotenv");
const axios = require("axios");
const mysql = require("mysql2/promise");
const mongoose = require("mongoose");

dotenv.config();

const app = express();
app.use(cors());
app.use(express.json());

// --- MongoDB Connection ---
const mongoUri = `mongodb://${process.env.MONGO_INITDB_ROOT_USERNAME}:${process.env.MONGO_INITDB_ROOT_PASSWORD}@${process.env.MONGODB_HOST}:${process.env.MONGODB_PORT}/${process.env.MONGODB_NAME}?authSource=admin`;

mongoose
  .connect(mongoUri)
  .then(() => console.log("‚úÖ ƒê√£ k·∫øt n·ªëi MongoDB"))
  .catch((err) => console.error("‚ùå L·ªói k·∫øt n·ªëi MongoDB:", err.message));

// --- MySQL Connection Pool ---
const pool = mysql.createPool({
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0,
});

// --- Schema Description Loading ---
let combinedSchemaDescription = "";

async function loadSchemaDescription() {
  let mysqlSchema = "MySQL Schema:\n";
  let mongoSchema = "MongoDB Schema:\n";

  try {
    console.log("‚è≥ Loading MySQL schema...");
    const [tables] = await pool.query("SHOW TABLES");
    const tableNames = tables.map((t) => Object.values(t)[0]);

    for (const table of tableNames) {
      const [columns] = await pool.query(`SHOW COLUMNS FROM \`${table}\``);
      const colDescriptions = columns
        .map((col) => `${col.Field} (${col.Type})`)
        .join(", ");
      mysqlSchema += `  Table "${table}": ${colDescriptions}\n`;
    }
    console.log("‚úÖ MySQL schema loaded.");
  } catch (error) {
    console.error("‚ùå Error loading MySQL schema:", error.message);
    mysqlSchema += "  Error loading schema.\n";
  }

  try {
    console.log("‚è≥ Loading MongoDB schema...");
    if (mongoose.connection.readyState === 1) {
      const collections = await mongoose.connection.db.listCollections().toArray();
      if (collections.length > 0) {
        mongoSchema += "  Collections:\n";
        for (const collection of collections) {
          mongoSchema += `    - ${collection.name}\n`;
        }
      } else {
        mongoSchema += "  No collections found.\n";
      }
      console.log("‚úÖ MongoDB schema loaded.");
    } else {
      mongoSchema += "  MongoDB not connected.\n";
      console.warn("‚ö†Ô∏è MongoDB schema not loaded: Connection not ready.");
    }
  } catch (error) {
    console.error("‚ùå Error loading MongoDB schema:", error.message);
    mongoSchema += "  Error loading schema.\n";
  }

  combinedSchemaDescription = `${mysqlSchema}\n${mongoSchema}`;
  console.log("üìã Combined Schema loaded:\n", combinedSchemaDescription);
}

setTimeout(loadSchemaDescription, 5000);

// --- API Endpoint ---
app.post("/api/chat", async (req, res) => {
  const { message } = req.body;

  if (!message) {
    return res.status(400).json({ error: "Missing 'message' in request body." });
  }

  if (!combinedSchemaDescription) {
    console.warn("‚ö†Ô∏è Schema description not loaded yet. Retrying load...");
    await loadSchemaDescription();
    if (!combinedSchemaDescription) {
      return res.status(503).json({ error: "Schema description is not available yet. Please try again later." });
    }
  }

  try {
    // STEP 1: Use Gemini to determine DB type and generate the query
    console.log(`[${new Date().toISOString()}] Received question: "${message}"`);
    const queryGenPrompt = `
D∆∞·ªõi ƒë√¢y l√† schema c∆° s·ªü d·ªØ li·ªáu k·∫øt h·ª£p t·ª´ MySQL v√† MongoDB:

${combinedSchemaDescription}

C√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng: "${message}"

Nhi·ªám v·ª•:
1. X√°c ƒë·ªãnh xem c√¢u h·ªèi n√†y li√™n quan ƒë·∫øn c∆° s·ªü d·ªØ li·ªáu 'mysql' hay 'mongodb'.
2. N·∫øu l√† 'mysql', h√£y t·∫°o c√¢u l·ªánh SQL h·ª£p l·ªá ƒë·ªÉ tr·∫£ l·ªùi c√¢u h·ªèi.
3. N·∫øu l√† 'mongodb', h√£y x√°c ƒë·ªãnh t√™n collection c√≥ li√™n quan v√† t·∫°o m·ªôt chu·ªói JSON h·ª£p l·ªá ƒë·∫°i di·ªán cho m·ªôt m·∫£ng c√°c giai ƒëo·∫°n Aggregation Pipeline cho ph∆∞∆°ng th·ª©c \`aggregate()\` c·ªßa MongoDB.
   - S·ª≠ d·ª•ng c√°c giai ƒëo·∫°n nh∆∞ $match, $sort, $limit, v.v. V√≠ d·ª•: "[{\"$match\": {\"price\": {\"$lt\": 10}}}, {\"$sort\": {\"price\": -1}}, {\"$limit\": 5}]".
   - T√™n giai ƒëo·∫°n ph·∫£i b·∫Øt ƒë·∫ßu b·∫±ng '$' (nh∆∞ $match, kh√¥ng ph·∫£i match).
   - ƒê·∫£m b·∫£o pipeline lu√¥n b·∫Øt ƒë·∫ßu b·∫±ng m·ªôt giai ƒëo·∫°n $match (c√≥ th·ªÉ l√† {} n·∫øu kh√¥ng c√≥ b·ªô l·ªçc c·ª• th·ªÉ).
4. Tr·∫£ v·ªÅ K·∫æT QU·∫¢ CH·ªà L√Ä M·ªòT ƒê·ªêI T∆Ø·ª¢NG JSON DUY NH·∫§T, kh√¥ng c√≥ gi·∫£i th√≠ch hay ƒë·ªãnh d·∫°ng markdown n√†o kh√°c.
   - N·∫øu l√† MySQL, JSON ph·∫£i c√≥ d·∫°ng: \`{"database": "mysql", "query": "SELECT ..."}\`
   - N·∫øu l√† MongoDB, JSON ph·∫£i c√≥ d·∫°ng: \`{"database": "mongodb", "collection": "t√™n_collection", "query": "[{\"$match\": {...}}, ...]}"}\`

V√≠ d·ª• JSON cho MongoDB: \`{"database": "mongodb", "collection": "menus", "query": "[{\"$match\": {\"price\": {\"$lt\": 10}}}, {\"$sort\": {\"price\": -1}}, {\"$limit\": 5}]"}\`
V√≠ d·ª• JSON cho MySQL: \`{"database": "mysql", "query": "SELECT name FROM products WHERE category = 'Electronics'"}\`

JSON Output:`;

    console.log("‚è≥ Calling Gemini for query generation...");
    const queryGenRes = await axios.post(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${process.env.GEMINI_API_KEY}`,
      {
        contents: [{ role: "user", parts: [{ text: queryGenPrompt }] }],
        generationConfig: { responseMimeType: "application/json" }
      },
      { headers: { 'Content-Type': 'application/json' } }
    );

    // Safely parse the Gemini response
    let queryInfo;
    try {
      const rawText = queryGenRes.data?.candidates?.[0]?.content?.parts?.[0]?.text || "";
      console.log("Raw Gemini Query Gen Response:", rawText);
      const cleanedJsonString = rawText.replace(/```json|```/g, "").trim();
      queryInfo = JSON.parse(cleanedJsonString);
      console.log("Parsed Query Info:", queryInfo);

      if (!queryInfo || !queryInfo.database || !queryInfo.query) {
        throw new Error("Invalid JSON structure from Gemini.");
      }
      if (queryInfo.database === "mongodb" && !queryInfo.collection) {
        throw new Error("Missing 'collection' field for mongodb query.");
      }
    } catch (parseError) {
      console.error("‚ùå Error parsing Gemini query generation response:", parseError.message);
      console.error("Raw response was:", queryGenRes.data?.candidates?.[0]?.content?.parts?.[0]?.text);
      return res.status(500).json({ error: "L·ªói x·ª≠ l√Ω ph·∫£n h·ªìi t·ª´ AI ƒë·ªÉ t·∫°o truy v·∫•n." });
    }

    // STEP 2: Execute the query against the appropriate database
    let results;
    let executedQuery = queryInfo.query;

    console.log(`‚è≥ Executing query on ${queryInfo.database}...`);
    if (queryInfo.database === "mysql") {
      executedQuery = queryInfo.query.replace(/`/g, '');
      console.log("SQL Query:", executedQuery);
      const [rows] = await pool.query(executedQuery);
      results = rows;
      console.log(`‚úÖ MySQL query executed. Found ${results.length} rows.`);
    } else if (queryInfo.database === "mongodb") {
      const collectionName = queryInfo.collection;
      let pipeline;

      try {
        if (typeof queryInfo.query === 'string') {
          pipeline = JSON.parse(queryInfo.query);
        } else {
          throw new Error("Query from Gemini is not a string as expected.");
        }

        // Ki·ªÉm tra xem pipeline l√† m·ªôt m·∫£ng
        if (!Array.isArray(pipeline)) {
          console.warn("‚ö†Ô∏è Gemini returned a non-array pipeline. Converting to array with $match.");
          pipeline = [{ $match: pipeline || {} }];
        }

        // L√†m s·∫°ch pipeline: s·ª≠a ho·∫∑c lo·∫°i b·ªè c√°c giai ƒëo·∫°n kh√¥ng h·ª£p l·ªá
        pipeline = pipeline.map(stage => {
          const stageKeys = Object.keys(stage);
          if (stageKeys.length === 0) {
            console.warn("‚ö†Ô∏è Empty stage detected. Replacing with $match: {}.");
            return { $match: {} };
          }
          const stageName = stageKeys[0];
          // S·ª≠a c√°c giai ƒëo·∫°n thi·∫øu '$' (nh∆∞ {match: {}} th√†nh {$match: {}})
          if (!stageName.startsWith('$')) {
            console.warn(`‚ö†Ô∏è Invalid stage name '${stageName}'. Converting to '$match'.`);
            return { $match: stage[stageName] || {} };
          }
          return stage;
        });

        // ƒê·∫£m b·∫£o pipeline c√≥ √≠t nh·∫•t m·ªôt giai ƒëo·∫°n $match
        if (!pipeline.some(stage => stage.$match)) {
          console.warn("‚ö†Ô∏è Pipeline does not include $match stage. Adding default $match: {}.");
          pipeline.unshift({ $match: {} });
        }

        // Ph√¢n t√≠ch c√¢u h·ªèi ƒë·ªÉ l·∫•y s·ªë l∆∞·ª£ng gi·ªõi h·∫°n (n·∫øu c√≥)
        let limit = 0;
        const match = message.match(/hi·ªÉn th·ªã\s+(\d+)\s+th·ª±c ƒë∆°n/i);
        if (match) {
          limit = parseInt(match[1], 10);
          // Th√™m ho·∫∑c thay th·∫ø giai ƒëo·∫°n $limit
          const limitIndex = pipeline.findIndex(stage => stage.$limit);
          if (limitIndex >= 0) {
            pipeline[limitIndex] = { $limit: limit };
          } else {
            pipeline.push({ $limit: limit });
          }
        }

        // Ki·ªÉm tra xem c√≥ n√™n d√πng find() hay aggregate()
        if (pipeline.length === 1 && pipeline[0].$match) {
          // Ch·ªâ c√≥ $match -> d√πng find()
          const filter = pipeline[0].$match || {};
          executedQuery = `db.collection('${collectionName}').find(${JSON.stringify(filter)})`;
          if (limit > 0) {
            executedQuery += `.limit(${limit})`;
          }
          console.log("MongoDB Find Query:", executedQuery);

          if (mongoose.connection.readyState !== 1) {
            console.error("‚ùå Cannot query MongoDB: Connection not ready.");
            return res.status(503).json({ error: "K·∫øt n·ªëi MongoDB ch∆∞a s·∫µn s√†ng." });
          }

          const collection = mongoose.connection.db.collection(collectionName);
          let query = collection.find(filter);
          if (limit > 0) {
            query = query.limit(limit);
          }
          results = await query.toArray();
          console.log(`‚úÖ MongoDB find executed on collection '${collectionName}'. Found ${results.length} documents.`);
        } else {
          // C√≥ c√°c giai ƒëo·∫°n kh√°c -> d√πng aggregate()
          executedQuery = `db.collection('${collectionName}').aggregate(${JSON.stringify(pipeline)})`;
          console.log("MongoDB Aggregation Pipeline:", executedQuery);

          if (mongoose.connection.readyState !== 1) {
            console.error("‚ùå Cannot query MongoDB: Connection not ready.");
            return res.status(503).json({ error: "K·∫øt n·ªëi MongoDB ch∆∞a s·∫µn s√†ng." });
          }

          const collection = mongoose.connection.db.collection(collectionName);
          results = await collection.aggregate(pipeline).toArray();
          console.log(`‚úÖ MongoDB aggregation executed on collection '${collectionName}'. Found ${results.length} documents.`);
        }
      } catch (mongoError) {
        console.error(`‚ùå Error executing MongoDB query on collection '${collectionName}':`, mongoError.message);
        return res.status(500).json({ error: `L·ªói khi th·ª±c thi truy v·∫•n tr√™n collection '${collectionName}' trong MongoDB.` });
      }
    } else {
      console.error(`‚ùå Unknown database type received from Gemini: ${queryInfo.database}`);
      return res.status(500).json({ error: "AI tr·∫£ v·ªÅ lo·∫°i c∆° s·ªü d·ªØ li·ªáu kh√¥ng x√°c ƒë·ªãnh." });
    }

    // STEP 3: Generate natural language answer
    console.log("‚è≥ Calling Gemini for natural language answer...");
    const resultPrompt = `
C√¢u h·ªèi g·ªëc c·ªßa ng∆∞·ªùi d√πng: "${message}"
C∆° s·ªü d·ªØ li·ªáu ƒë∆∞·ª£c truy v·∫•n: ${queryInfo.database}
C√¢u truy v·∫•n ƒë√£ th·ª±c thi: ${typeof executedQuery === 'string' ? executedQuery : JSON.stringify(executedQuery)}
K·∫øt qu·∫£ (${results.length} b·∫£n ghi): ${JSON.stringify(results)}

üëâ D·ª±a v√†o c√¢u h·ªèi v√† k·∫øt qu·∫£ truy v·∫•n, h√£y vi·∫øt m·ªôt c√¢u tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát t·ª± nhi√™n, th√¢n thi·ªán cho ng∆∞·ªùi d√πng.
   - KH√îNG hi·ªÉn th·ªã d·ªØ li·ªáu d·∫°ng JSON th√¥.
   - KH√îNG ƒë·ªÅ c·∫≠p ƒë·∫øn c√∫ ph√°p SQL hay MQL.
   - Tr√¨nh b√†y k·∫øt qu·∫£ m·ªôt c√°ch r√µ r√†ng, d·ªÖ hi·ªÉu. N·∫øu kh√¥ng c√≥ k·∫øt qu·∫£, h√£y th√¥ng b√°o nh∆∞ v·∫≠y.

C√¢u tr·∫£ l·ªùi t·ª± nhi√™n:`;

    const replyRes = await axios.post(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${process.env.GEMINI_API_KEY}`,
      {
        contents: [{ role: "user", parts: [{ text: resultPrompt }] }],
      },
      { headers: { 'Content-Type': 'application/json' } }
    );

    const answer =
      replyRes.data?.candidates?.[0]?.content?.parts?.[0]?.text ||
      "Xin l·ªói, t√¥i kh√¥ng th·ªÉ t·∫°o c√¢u tr·∫£ l·ªùi t·ª± nhi√™n v√†o l√∫c n√†y.";

    console.log("‚úÖ Natural language answer generated."+ " Answer: "+answer);
    res.json({
      database: queryInfo.database,
      query: executedQuery,
      result: results,
      answer: answer.trim(),
    });
  } catch (error) {
    console.error("‚ùå Error in /api/chat:", error.response ? JSON.stringify(error.response.data) : error.message);
    if (error.response && error.response.data && error.response.data.error) {
      console.error("Gemini API Error:", error.response.data.error.message);
      res.status(500).json({ error: `L·ªói t·ª´ AI: ${error.response.data.error.message}` });
    } else if (error.code) {
      res.status(500).json({ error: `L·ªói c∆° s·ªü d·ªØ li·ªáu: ${error.message} (Code: ${error.code})` });
    } else {
      res.status(500).json({ error: "ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën trong qu√° tr√¨nh x·ª≠ l√Ω y√™u c·∫ßu." });
    }
  }
});

// --- Server Start ---
const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`üöÄ Server running on http://localhost:${PORT}`);
  console.log(`Connect to MongoDB at: ${process.env.MONGODB_HOST}:${process.env.MONGODB_PORT}`);
  console.log(`Connect to MySQL at: ${process.env.DB_HOST}`);
});